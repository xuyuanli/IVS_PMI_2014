!  GLS.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  1/29/2014 2:47:19 PM
Module GLS
contains

!1.1General 
!******************stdev of data************
!stdev
subroutine sdf(a,n,b)
implicit none
real(8),intent(in)::a(:)
integer(8),intent(in)::n
real(8),intent(out)::b(:)
integer(8)::i
real(8)::ave,sda

ave=0.0
do i=1,n
   ave=ave+a(i)
end do
ave=ave/real(n)   

sda=0.0
do i=1,n
   sda=sda+(a(i)-ave)**2.0
end do
sda=dsqrt(sda/real(n-1))  

do i=1,n
   b(i)=(a(i)-ave)/sda
end do
   
end subroutine 
!***************End sd of data***************

!*************************************************************************
   !scale to [0,1] with two boundary at 0 and 1
   subroutine scaling(datain,n,dataout)  
   real(8),intent(in)::datain(:)
   integer(8),intent(in)::n
   real(8),intent(out)::dataout(:)
   real(8)::a1,a2   !min & max values
   integer(8)::i
   
   a1=maxval(datain)
   a2=minval(datain)
   
   do i=1,n
      dataout(i)=(datain(i)-a2)/(a1-a2)
   end do
     
   end subroutine
!*************************************************************************  

!******************stdev of data*************
!stdev
subroutine sds(a,n,sda)
implicit none
real(8),intent(in)::a(:)
integer(8),intent(in)::n
real(8),intent(out)::sda
integer(8)::i
real(8)::ave

ave=0.0
do i=1,n
   ave=ave+a(i)
end do
ave=ave/real(n)   

sda=0.0
do i=1,n
   sda=sda+(a(i)-ave)**2.0
end do
sda=dsqrt(sda/real(n-1))  
   
end subroutine 
!***************End sd of data***************



!**************Mean**************************
subroutine aves(a,n,means)
implicit none
real(8),intent(in)::a(:)
integer(8),intent(in)::n
real(8),intent(out)::means
integer(8)::i

means=0.0
 do i=1,n
    means=means+a(i)
 end do   
means=means/real(n)

end subroutine
!***********End Mean************************

!**************Skewness*********************
!(n/(n-1)/(n-2))*(sum(xj-ave)/s)^3
subroutine skews(a,n,g)
implicit none
real(8),intent(in)::a(:)
integer(8),intent(in)::n
real(8),intent(out)::g
integer(8)::i
real(8)::p1,p2

p1=0.0
do i=1,n
   p1=p1+a(i)
end do   
p1=p1/real(n)

p2=0.0
do i=1,n
   p2=p2+(a(i)-p1)**2.0
end do
p2=dsqrt(p2/real(n-1))

g=0.0
do i=1,n
   g=g+((a(i)-p1)/p2)**3.0
end do   
g=g*real(n/(n-1.0)/(n-2.0))

end subroutine
!***********End Skewness**************


!******************Kurtosis of data******
!Kurtosis
!n*(n+1)/(n-1)/(n-2)/(n-3)*CM4/(CM2^2)-3*(n-1)**2.0/(n-2)/(n-3)
subroutine kurt(a,n,kt)
implicit none
real(8),intent(in)::a(:)
integer(8),intent(in)::n
real(8),intent(out)::kt
integer(8)::i
real(8)::ave,sum1,sum2

ave=0.0
do i=1,n
   ave=ave+a(i)
end do
ave=ave/real(n)   

sum2=0.0
do i=1,n
   sum2=sum2+(a(i)-ave)**2.0
end do
sum2=dsqrt(sum2/real(n-1.0))

sum1=0.0
do i=1,n
   sum1=sum1+((a(i)-ave)/sum2)**4.0
end do

kt=sum1*n*(n+1.0)/(n-1.0)/(n-2.0)/(n-3.0)-3.0*(n-1.0)**2.0/(n-2.0)/(n-3.0)
   
end subroutine 
!***************End Kurtosis****************




!1.2 Statistical parameters of residual errors (Dimensionless parameters)
!Nash-Sutcliffe efficiency 
subroutine CE(output1,output2,n1,cev)
implicit none
real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::cev
integer(8)::c1
real(8)::ave,sum1,sum2

ave=0.0
do c1=1,n1
   ave=ave+output1(c1)
end do
ave=ave/real(n1)

sum1=0.0
sum2=0.0
do c1=1,n1
   sum1=sum1+(output1(c1)-output2(c1))**2.0
   sum2=sum2+(output1(c1)-ave)**2.0
end do

cev=1.0-sum1/sum2

end subroutine

!Modifided Nash-Sutcliffe efficiency (Krause et al. 2005)
subroutine MCE(output1,output2,n1,mcev)
implicit none
real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::mcev
integer(8)::c1
real(8)::ave,sum1,sum2

ave=0.0
do c1=1,n1
   ave=ave+output1(c1)
end do
ave=ave/real(n1)

sum1=0.0
sum2=0.0
do c1=1,n1
   sum1=sum1+abs(output1(c1)-output2(c1))
   sum2=sum2+abs(output1(c1)-ave)
end do

mcev=1.0-sum1/sum2

end subroutine

!Index of agreement
subroutine IoAd(output1,output2,n1,ioadv)
implicit none

real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::ioadv
integer(8)::c1
real(8)::ave,sum1,sum2

ave=0.0
do c1=1,n1
   ave=ave+output1(c1)
end do
ave=ave/real(n1)

sum1=0.0
sum2=0.0
do c1=1,n1
   sum1=sum1+(output1(c1)-output2(c1))**2.0
   sum2=sum2+(abs(output2(c1)-ave)+abs(output1(c1)-ave))**2.0
end do

ioadv=1.0-sum1/sum2

end subroutine

!Modifided index of agreement (Krause et al. 2005)
subroutine MIoAd(output1,output2,n1,mioadv)
implicit none

real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::mioadv
integer(8)::c1
real(8)::ave,sum1,sum2

ave=0.0
do c1=1,n1
   ave=ave+output1(c1)
end do
ave=ave/real(n1)

sum1=0.0
sum2=0.0
do c1=1,n1
   sum1=sum1+abs(output1(c1)-output2(c1))
   sum2=sum2+(abs(output2(c1)-ave)+abs(output1(c1)-ave))
end do

mioadv=1.0-sum1/sum2

end subroutine

!Persistence Index
subroutine PI(output1,output2,n1,piv)
implicit none

real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::piv
integer(8)::c1
real(8)::sum1,sum2

sum1=0.0
do c1=1,n1
   sum1=sum1+(output1(c1)-output2(c1))**2.0  
end do

sum2=0.0
do c1=2,n1
   sum2=sum2+(output1(c1)-output1(c1-1))**2.0  
end do

piv=1.0-sum1/sum2

end subroutine

!Modifided Persistence Index
subroutine MPI(output1,output2,n1,piv)
implicit none

real(8),intent(in)::output1(:),output2(:)
integer(8),intent(in)::n1
real(8),intent(out)::piv
integer(8)::c1
real(8)::sum1,sum2

sum1=0.0
do c1=1,n1
   sum1=sum1+abs(output1(c1)-output2(c1)) 
end do

sum2=0.0
do c1=2,n1
   sum2=sum2+abs(output1(c1)-output1(c1-1)) 
end do

piv=1.0-sum1/sum2

end subroutine
!************************End performance***********************



!1.3 
!*************GRNN prediction with GRNN(1-1)*********************
subroutine GRNN(xs,y,n,xg)
implicit none
real(8),intent(in)::xs(:),y(:)
integer(8),intent(in)::n
real(8),intent(out)::xg(:)
real(8)::num,den,hbw,sdv
integer(8)::c1,c2,c3,c4
real(8)::a1,a2,a3,a4,tmin
real(8),allocatable::aj(:),DIF(:)
real(8),allocatable::h1(:),t1(:)

allocate(aj(n))
allocate(DIF(n))
allocate(h1(10))
allocate(t1(10))

call sds(xs,n,sdv)
hbw=(4.0/(1.0+2.0))**(1.0/(1.0+4.0))*sdv*n**(-1.0/(1.0+4.0)) 

do c1=1,n    
         num=0.0
         den=0.0
         do c2=1,n
            if (c2==c1) then
            num=num
            den=den
            else 
            DIF(c2)=(xs(c2)-xs(c1))**2.0/2.0/(hbw)**2.0
            aj(c2)=exp(-DIF(c2))  
            num=num+y(c2)*aj(c2)
            den=den+aj(c2)
            end if 
          end do
            
       if (abs(den)<1.0*10.0**(-6.0)) then
           xg(c1)=num/10.0**(-6.0)     !warning: den=0.0
       else   
           xg(c1)=num/den !estimated output   
       end if   
       
end do 

deallocate(aj)
deallocate(DIF)
deallocate(h1)
deallocate(t1)

end subroutine

!*********************************End GRNN***************************************

!*********************************SVOGRNN**********************************************
!Optimiser 1D (GSS)
!This code is based upon 'NUMERICAL RECIPES IN FORTRAN77: THE ART OF SCIENTIFIC COMPUTING
!Routine for Golden Section Search
!Input boundary values, mid-value
!return the value minimising function
subroutine GSSSP(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=SE(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=SE(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=SE(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=SE(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function ESSO(h)
real(8) function SE(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2

allocate(ye(xr))

call GRNNTEST(x,y,xr,hg,ye)

SE=0.0
do c2=1,xr
   SE=SE+(ye(c2)-y(c2))**2.0  !SE
end do
   SE=SE/real(xr)

deallocate(ye)

end function

!==================================================================================================  
subroutine GRNNTEST(xs,y,n,htest,xg)
implicit none
real(8),intent(in)::xs(:),y(:),htest
integer(8),intent(in)::n
real(8),intent(out)::xg(:)
real(8)::num,den,hbw
integer(8)::c1,c2
real(8),allocatable::aj(:),DIF(:)

allocate(aj(n))
allocate(DIF(n))

do c1=1,n    
         num=0.0
         den=0.0
         do c2=1,n
            if (c2==c1) then
            num=num
            den=den
            else 
            DIF(c2)=(xs(c2)-xs(c1))**2.0/2.0/(htest)**2.0
            aj(c2)=exp(-DIF(c2))  
            num=num+y(c2)*aj(c2)
            den=den+aj(c2)
            end if 
          end do
            
       if (abs(num)<1.0*10.0**(-6.0)) then
           xg(c1)=num/10.0**(-6.0)     
       else   
           xg(c1)=num/den !estimated output   
       end if   
       
end do 

deallocate(aj)
deallocate(DIF)

end subroutine
!==================================================================================================


!***********************************************************
!*************GRNN prediction with trial & error (SO)*******
subroutine GRNNSO(xs,y,n,xg)
implicit none
real(8),intent(in)::xs(:),y(:)
integer(8),intent(in)::n
real(8),intent(out)::xg(:)
real(8)::num,den,hbw
integer(8)::c1,c2,c3,c4
real(8)::a1,a2,a3,a4,tmin
real(8),allocatable::aj(:),DIF(:)
real(8),allocatable::h1(:),t1(:)

allocate(aj(n))
allocate(DIF(n))
allocate(h1(10))
allocate(t1(10))

   a1=minval(xs)
   a3=maxval(xs)
   a2=(a1+a3)/2.0
   call GSSSP(a1,a2,a3,xs,y,n,hbw) 

do c1=1,n    
         num=0.0
         den=0.0
         do c2=1,n
            if (c2==c1) then
            num=num
            den=den
            else 
            DIF(c2)=(xs(c2)-xs(c1))**2.0/2.0/(hbw)**2.0
            aj(c2)=exp(-DIF(c2))  
            num=num+y(c2)*aj(c2)
            den=den+aj(c2)
            end if 
          end do
            
       if (abs(num)<1.0*10.0**(-6.0)) then
           xg(c1)=num/10.0**(-6.0)     !warning: den=0.0
       else   
           xg(c1)=num/den !estimated output   
       end if   
       
end do 

deallocate(aj)
deallocate(DIF)
deallocate(h1)
deallocate(t1)

end subroutine

!*********************************End SVOGRNN***************************************

!*********************************RC************************************************

subroutine GSSRC(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSORC(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSORC(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSORC(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSORC(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function ESSO(h)
real(8) function ESSORC(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2
real(8)::num,dem,sum1,sum2,aj

allocate(ye(xr))

do c1=1,xr
   num=0.0
   dem=0.0
   do c2=1,xr 
      if (c2==c1) then
          num=num
          dem=dem
      else   
          if (x(c2)<hg) then
              sum1=(x(c2)-x(c1))**2.0/2.0/hg**2.0
              sum2=(x(c2)+x(c1))**2.0/2.0/hg**2.0
              aj=dexp(-sum1)+dexp(-sum2)
          else
              sum1=(x(c2)-x(c1))**2.0/2.0/hg**2.0
              aj=dexp(-sum1)
          end if
      
            num=num+y(c2)*aj
            dem=dem+aj 
      end if      
    end do

   if (abs(dem)<1.0*10.0**(-6.0)) then
         ye(c1)=num/10.0**(-6.0)     !warning: den=0.0
   else   
         ye(c1)=num/dem !estimated output   
   end if    
end do

ESSORC=0.0
do c2=1,xr
   ESSORC=ESSORC+(ye(c2)-y(c2))**2.0  !SE
end do
   ESSORC=ESSORC/real(xr)

deallocate(ye)

end function
!**************************End RC***************************************

!************************Bounday kernel************************
    real(8) function kc(c,t)
    implicit none
    
    real(8),intent(in)::c,t
    
    kc=12.0/(1.0+c)**4.0*(1.0+t)*((1.0-2.0*c)*t+(3.0*c**2.0-2.0*c+1.0)/2.0)
    end function
!***********************End bounday kernel***********************

!*********************************BK************************************************

subroutine GSSBK(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSOBK(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSOBK(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSOBK(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSOBK(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function ESSO(h)
real(8) function ESSOBK(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2
real(8)::num,den,sum1,sum2,aj,cv,hc,kx

allocate(ye(xr))

do c1=1,xr
   num=0.0
   den=0.0
   do c2=1,xr
      if (c2==c1) then
          num=num
          den=den
      else
          cv=min(x(c1)/hg,1.0)
          hc=(2.0-cv)*hg
          kx=(x(c2)-x(c1))/hc
       if(kx<-1.0 .or. kx>cv) then
          aj=0.0
       else
          aj=kc(cv,kx)
       end if        
          num=num+aj*y(c2)
          den=den+aj
       end if            
    end do
    
     if (dabs(den)<1.0*10.0**(-6.0)) then
         ye(c1)=num/10.0**(-6.0)     !warning: den=0.0
     else   
         ye(c1)=num/den !estimated output   
     end if 
end do

ESSOBK=0.0
do c2=1,xr
   ESSOBK=ESSOBK+(ye(c2)-y(c2))**2.0  !SE
end do
   ESSOBK=ESSOBK/real(xr)

deallocate(ye)

end function


!**************************End BK******************************


!***************************PA**********************************
!ordering data

  subroutine dataord(xi,ns,xo)
  implicit none
  
  real(8)::xi(:)
  integer(8),intent(in)::ns
  real(8),intent(out)::xo(:)
  integer(8)::i,j
  real(8)::tm,tr  !minimal data in each iteration, replacement
  
  tm=maxval(xi)*5
    
  do i=1,ns   
     tr=minval(xi)
     do j=1,ns
        if (xi(j)==tr) then
           xo(i)=xi(j)
           xi(j)=tm
           go to 11    !Avoid more than one same values
        else
           xo(i)=xo(i)
        end if         
     end do
     11 write(*,*)
  end do    
  
  end subroutine

!**********************************************************************
! data interpolation 
  
  subroutine dataint(xi,ns1,xo)
  implicit none
  
  real(8),intent(in)::xi(:)
  integer(8),intent(in)::ns1
  real(8),intent(out)::xo(:)
  integer(8)::i,j,k
  
  do i=1,ns1
     k=3*i-2
     xo(k)=xi(i)
  end do   
   
  do i=1,ns1-1
     do j=1,2
        k=3*i-2+j
        xo(k)=(xi(i+1)-xi(i))*real(j/3.0)+xi(i)
     end do
  end do
  
  end subroutine
!**********************************************************************

! data generation
 
   subroutine datapse(xi,ns1,xo) 
   implicit none
   
   real(8),intent(in)::xi(:)
   integer(8),intent(in)::ns1
   real(8),intent(out)::xo(:)
   integer(8)::i,j,k
   
   do i=1,ns1
      xo(i)=-5.0*xi(i)-4.0*xi(2*i)+10.0/3.0*xi(3*i)
   end do
   
   end subroutine
   
    !Optimiser 1D (GSS)
    !This code is based upon 'NUMERICAL RECIPES IN FORTRAN77: THE ART OF SCIENTIFIC COMPUTING
    !Routine for Golden Section Search
    !Input boundary values, mid-value
    !return the value minimising function
    subroutine GSS_PAK(ax,bx,cx,in,inpd,out,r2,hb,minx)      !low, mid, up guessing, input data, size, average, minTarget, minValue
    implicit none
    real(8),intent(in)::in(:),hb,inpd(:),out(:)
    integer(8),intent(in)::ax,bx,cx
    integer(8),intent(in)::r2
    integer(8),intent(out)::minx
    real(8)::tol,r1,c1,minf  
    integer(8)::x0,x1,x2,x3
    real(8)::f1,f2    !dummy variables

    r1=(1.0+dsqrt(5.0_8))/2.0-1.0
    c1=1.0-r1
    x0=ax
    x3=cx
    if(abs(cx-bx)>abs(bx-ax))then  
       x1=int(bx)
       x2=int(bx+c1*(cx-bx))
    else
       x2=int(bx)
       x1=int(bx-c1*(bx-ax))
    end if
 
     f1=ksf(in,inpd,out,hb,r2,x1) !Initial evaluation
     f2=ksf(in,inpd,out,hb,r2,x2)
     tol=0.0001
do while (abs(x1-x2)>1_8)
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=int(r1*x1+c1*x3)
      f1=f2
      f2=ksf(in,inpd,out,hb,r2,x2) 
   else
      x3=x2
      x2=x1
      x1=int(r1*x2+c1*x0)
      f2=f1
      f1=ksf(in,inpd,out,hb,r2,x1)   
   end if 
end do

     if (f1<f2) then
         minx=x1
         minf=f1
     else
         minx=x2 
         minf=f2  
     end if

end subroutine

!****************************************************
     real(8) function ksf(xin,xinpd,yout,hbv,ns,kst)
     implicit none
     
     real(8),intent(in)::xin(:),xinpd(:),yout(:),hbv
     integer(8),intent(in)::ns,kst
     integer(8)::i,j
     real(8)::sum1,sum2,sum3,ksiv,dem,num
     real(8),allocatable::fi(:)
     
     allocate(fi(ns))
     
     do i=1,ns
       dem=0.0
       num=0.0
       do j=1,ns
         if(j==i) then
           dem=dem
           num=num
         else  
            if (j<=kst) then
             sum1=(xin(j)-xin(i))**2.0/2.0/(hbv**2.0)
             sum3=(xinpd(j)-xin(i))**2.0/2.0/(hbv**2.0)   
             sum2=dexp(-sum1)+dexp(-sum3)            
            else   
             sum1=(xin(j)-xin(i))**2.0/2.0/(hbv**2.0)
             sum2=dexp(-sum1)     
            end if 
          
           num=num+yout(j)*sum2
           dem=dem+sum2
         end if      
        end do
       
         if (abs(dem)<1.0*10.0**(-6.0)) then
           fi(i)=num/10.0**(-6.0)     !warning: den=0.0
         else   
           fi(i)=num/dem !estimated output   
         end if
         
     end do  
     
     call CE(yout,fi,ns,ksiv) 
     
     ksf=ksiv
     
     deallocate(fi)
     
     end function

!*******************************End of PA****************

!******************************LBR************************
subroutine GSSLBR(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSOLBR(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSOLBR(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSOLBR(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSOLBR(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine
!****************************End of GSS*********************************

!Function ESSO(h)
real(8) function ESSOLBR(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2
real(8)::num,den,kh,aj,hw,a

allocate(ye(xr))

a=minval(x)

do c1=1,xr
   num=0.0
   den=0.0
      
    do c2=1,xr
       
       if (c2==c1) then
           num=num
           den=den
       else if(x(c2)<=hg) then
           hw=max((x(c2)-a),0.000001) 
           aj=dexp((x(c2)-x(c1))**2.0/2.0/(hw)**2.0) 
           num=num+y(c2)*aj
           den=den+aj
       else 
           hw=hg
           aj=dexp((x(c2)-x(c1))**2.0/2.0/(hg)**2.0) 
           num=num+y(c2)*aj
           den=den+aj       
       end if
     end do         
    
    
   if (den<=1.0*10.0**(-6.0)) then
       ye(c1)=num/10.0**(-6.0)
   else  
       ye(c1)=num/den
   end if    
        
end do    
 
ESSOLBR=0.0
do c2=1,xr
   ESSOLBR=ESSOLBR+(ye(c2)-y(c2))**2.0  !SE
end do
   ESSOLBR=ESSOLBR/real(xr)

deallocate(ye)

end function
!*******************************End LBR*********************************

!*********************************LLP*********************
subroutine GSSLLE(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSOLLE(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSOLLE(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSOLLE(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSOLLE(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine


!Function ESSO(h)
real(8) function ESSOLLE(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2
real(8)::num,s0,s1,s2,kh,aj

allocate(ye(xr))

do c1=1,xr
   num=0.0
   s0=0.0
   s1=0.0
   s2=0.0
   
   do c2=1,xr
      kh=dexp(-(x(c2)-x(c1))**2.0/2.0/hg**2.0)&
*((2.0*3.141592653)**(1.0/2.0)*hg**1.0)**(-1.0)
      s0=s0+kh 
      s1=s1+(x(c2)-x(c1))*kh
      s2=s2+(x(c2)-x(c1))**2.0*kh
    end do
      s0=s0/xr
      s1=s1/xr
      s2=s2/xr
    
    do c2=1,xr
       if (c2==c1) then
           num=num
       else
          kh=dexp(-(x(c2)-x(c1))**2.0/2.0/hg**2.0)&
*((2.0*3.141592653)**(1.0/2.0)*hg**1.0)**(-1.0)
        if ((s2*s0-s1**2.0)<0.0000001) then
            num=num+(s2-s1*(x(c2)-x(c1)))*y(c2)*kh/0.0000001
        else
            num=num+(s2-s1*(x(c2)-x(c1)))*y(c2)*kh/(s2*s0-s1**2.0)
        end if
       end if
     end do         
    
    
   if (num<=1.0*10.0**(-6.0)) then
       ye(c1)=1.0*10.0**(-6.0)/real(xr)
   else  
       ye(c1)=num/xr
   end if    
        
end do    

  
ESSOLLE=0.0
do c2=1,xr
   ESSOLLE=ESSOLLE+(ye(c2)-y(c2))**2.0  !SE
end do
   ESSOLLE=ESSOLLE/real(xr)

deallocate(ye)

end function
!********************************end LLP*********************************

!**********************************LQP**************************
subroutine GSSLQP(ax,bx,cx,in,out,ro,minx)      !low, mid, up guessing, input data, size, minTatget, minValue
implicit none

real(8),intent(in)::ax,bx,cx,in(:),out(:)
integer(8),intent(in)::ro
real(8),intent(out)::minx
real(8)::tol,r1,c1   !left, right bracket; in-between point; target parameter, tolerance, constant, C_hat for g
real(8)::f1,f2,x0,x1,x2,x3,minf    !dummy variables

r1=(1.0+dsqrt(5.0_8))/2.0-1.0
c1=1.0-r1
x0=ax
x3=cx
if(abs(cx-bx)>abs(bx-ax))then  
    x1=bx
    x2=bx+c1*(cx-bx)
else
    x2=bx
    x1=bx-c1*(bx-ax)
end if

f1=ESSOLQP(in,out,ro,x1) !Initial evaluation (optimise single variable based upon error sqaure)
f2=ESSOLQP(in,out,ro,x2)
tol=0.0001
do while (abs(x3-x0)>tol*(abs(x1)+abs(x2)))
   if (f2<f1) then
      x0=x1
      x1=x2
      x2=r1*x1+c1*x3
      f1=f2
      f2=ESSOLQP(in,out,ro,x2)  
   else
      x3=x2
      x2=x1
      x1=r1*x2+c1*x0
      f2=f1
      f1=ESSOLQP(in,out,ro,x1)     
   end if 
end do

if (f1<f2) then
    minx=x1
    minf=f1
else
    minx=x2
    minf=f2   
end if

end subroutine


!Function ESSO(h)
real(8) function ESSOLQP(x,y,xr,hg)
implicit none
real(8),intent(in)::x(:),y(:),hg
integer(8),intent(in)::xr
real(8),allocatable::ye(:)
integer(8)::c1,c2
real(8)::num,s0,s1,s2,s3,s4,kh,aj

allocate(ye(xr))

do c1=1,xr
   num=0.0
      s0=0.0
      s1=0.0
      s2=0.0
      s3=0.0
      s4=0.0
   
   do c2=1,xr
      kh=dexp(-(x(c2)-x(c1))**2.0/2.0/hg**2.0)&
*((2.0*3.141592653)**(1.0/2.0)*hg**1.0)**(-1.0)
      s0=s0+kh 
      s1=s1+(x(c2)-x(c1))*kh
      s2=s2+(x(c2)-x(c1))**2.0*kh
      s3=s3+(x(c2)-x(c1))**3.0*kh
      s4=s4+(x(c2)-x(c1))**4.0*kh
    end do
      s0=s0/xr
      s1=s1/xr
      s2=s2/xr
      s3=s3/xr
      s4=s4/xr
    
    do c2=1,xr
       if (c2==c1) then
           num=num
       else
          kh=dexp(-(x(c2)-x(c1))**2.0/2.0/hg**2.0)&
*((2.0*3.141592653)**(1.0/2.0)*hg**1.0)**(-1.0)
        if ((s0*(s2*s4-s3*s3)-s1*(s4*s1-s3*s2)+s2*(s1*s3-s2*s2))<0.0000001) then
num=num+((s2*s4-s3*s3)-(s1*s4-s2*s3)*(x(c2)-x(c1))+(s1*s3-s2*s2)*(x(c2)-x(c1))**2.0)*y(c2)*kh/0.0000001
        else
num=num+((s2*s4-s3*s3)-(s1*s4-s2*s3)*(x(c2)-x(c1))+(s1*s3-s2*s2)*(x(c2)-x(c1))**2.0)*y(c2)*kh&
/(s0*(s2*s4-s3*s3)-s1*(s4*s1-s3*s2)+s2*(s1*s3-s2*s2))
        end if
       end if
     end do         
    
    
   if (num<=1.0*10.0**(-6.0)) then
       ye(c1)=1.0*10.0**(-6.0)/real(xr)
   else  
       ye(c1)=num/xr
   end if    
        
end do    

  
ESSOLQP=0.0
do c2=1,xr
   ESSOLQP=ESSOLQP+(ye(c2)-y(c2))**2.0  !SE
end do
   ESSOLQP=ESSOLQP/real(xr)

deallocate(ye)

end function
!********************************end LQP*********************************

!**********************************PSO MLPANN*********************************
!*****************************PSO MAIN MLP_ANN (0HN)**************************  
Subroutine PSOA0(ix,oy,r,c,sp)  

USE mod_PSO, ONLY: type_PSO_swarm, read_PSO_swarm_from_file, initialise_PSO_swarm,&
re_initialise_PSO_swarm, update_PSO_swarm_bests, update_PSO_swarm_parameters,&
update_PSO_swarm_locations, perturb_PSO_swarm_locations,& 
store_PSO_iteration_data,print_PSO_swarm_iteration_statistics
        
    IMPLICIT NONE
    real(8)::ix(:),oy(:)
    integer(8)::r,c     
    TYPE(type_PSO_swarm), TARGET:: swarm
    REAL(8):: f
    INTEGER(8):: i, j 
    real(8)::sp(:)

    
    CALL set_PSO_parameters(swarm)
    CALL initialise_PSO_swarm(swarm)
! Performing optimisation 
    DO i = 1, swarm%NImax 
      CALL update_PSO_swarm_parameters(swarm,i)
	  DO j = 1, swarm%Nparticle
! Evaluating the particle objective function values
        CALL ComputeObjectiveFunction0(ix,oy,r,c,(-5.0000+10.0000*(swarm%particle(j)%x)),f)  
        swarm%particle(j)%f = f
	  END DO
! Adjusting the PSO parameters
      CALL update_PSO_swarm_bests(swarm)
	  CALL store_PSO_iteration_data(swarm,i)
      CALL update_PSO_swarm_locations(swarm) 
	END DO
	
	!CALL print_PSO_swarm_iteration_statistics(swarm, 10_8)
	
	do i=1,swarm%Nx
	    sp(i)=-5.0000+10.0000*swarm%GB(1)%x(i)
	end do
  
  CONTAINS
!==================================================================================================
  SUBROUTINE set_PSO_parameters(swarm)
  
    USE mod_PSO, ONLY: type_PSO_swarm
  
    TYPE(type_PSO_swarm), INTENT(INOUT) :: swarm
    
    ! Control Parameters
    swarm%NeighbourhoodFlag = 'vonNeumannU' ! Type of neighbouthood structure
	swarm%Nparticle         = 100           ! Number of particles
	swarm%Nelite            = 2             ! Number of elitist particles
	swarm%NImax             = 100           ! Maximum number of iterations
	swarm%Nx                = 2             ! Size of decision string *******************need to adjust
	! Standard searching parameters
	swarm%cNB               = 2.0		    ! Weighting coefficient for GB particle 
	swarm%cPB               = 2.0		    ! Weighting coefficient for PB particle
	swarm%cInertiaMax       = 0.9		    ! Maximum inertia coefficient
	swarm%cInertiaMin       = 0.4		    ! Minimum inertia coefficient
	swarm%vMax              = 0.5		    ! Velocity component bound
	! Secondary searching parameters (not needed unless difficult problem, set swarm%perturbNI > swarm%NImax to not use)
	swarm%perturbExp        = 5.0		    ! Perturbation Exponent
	swarm%perturbProb       = 0.20		    ! Perturbation Probability
	swarm%perturbEs         = 0.000005	    ! Expected value for start
	swarm%perturbEe         = 0.0000000005	! Expected value for end
	swarm%perturbNI         = 10001		    ! Start iteration for perturbation
  
  END SUBROUTINE set_PSO_parameters
!==================================================================================================
  SUBROUTINE ComputeObjectiveFunction0(x,y,xr,xc,wp,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::AICk                  !Performance criteria 
    real(8),allocatable::xs(:),ys(:),ye(:)    !Scaled and estimated output
    real(8)::ymin,ymax
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))
    allocate(ye(xr))
    
    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       do c2=1,xc
          ye(c1)=ye(c1)+xs(c1)*wp(c2)
       end do
       ye(c1)=(ye(c1)+wp(xc+1))*(ymax-ymin)+ymin
    end do         

  
  AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)
   
    deallocate(xs)
    deallocate(ys)
    deallocate(ye)
   
  END SUBROUTINE ComputeObjectiveFunction0
!==================================================================================================
end subroutine

SUBROUTINE ANN0HN(x,y,xr,xc,wp,ye,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::ye(:),AICk            !Estimated output/Performance criteria 
    real(8),allocatable::xs(:),ys(:)          !Scaled and estimated output
    real(8)::ymin,ymax
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))

    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       do c2=1,xc
          ye(c1)=ye(c1)+xs(c1)*wp(c2)
       end do
       ye(c1)=(ye(c1)+wp(xc+1))*(ymax-ymin)+ymin
    end do     
    
     AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)    

    deallocate(xs)
    deallocate(ys)
  
  end subroutine
  !***********************End of 0HN******************************************


!*****************************PSO MAIN MLP_ANN (1HN)**************************  
Subroutine PSOA1(ix,oy,r,c,sp)  

USE mod_PSO, ONLY: type_PSO_swarm, read_PSO_swarm_from_file, initialise_PSO_swarm,&
re_initialise_PSO_swarm, update_PSO_swarm_bests, update_PSO_swarm_parameters,&
update_PSO_swarm_locations, perturb_PSO_swarm_locations,& 
store_PSO_iteration_data,print_PSO_swarm_iteration_statistics
        
    IMPLICIT NONE
    real(8)::ix(:),oy(:)
    integer(8)::r,c     
    TYPE(type_PSO_swarm), TARGET:: swarm
    REAL(8):: f
    INTEGER(8):: i, j 
    real(8)::sp(:)

    
    CALL set_PSO_parameters(swarm)
    CALL initialise_PSO_swarm(swarm)
! Performing optimisation 
    DO i = 1, swarm%NImax 
      CALL update_PSO_swarm_parameters(swarm,i)
	  DO j = 1, swarm%Nparticle
! Evaluating the particle objective function values
        CALL ComputeObjectiveFunction1(ix,oy,r,c,(-5.0000+10.0000*(swarm%particle(j)%x)),f)  
        swarm%particle(j)%f = f
	  END DO
! Adjusting the PSO parameters
      CALL update_PSO_swarm_bests(swarm)
	  CALL store_PSO_iteration_data(swarm,i)
      CALL update_PSO_swarm_locations(swarm) 
	END DO
	
	!CALL print_PSO_swarm_iteration_statistics(swarm, 10_8)
	
	do i=1,swarm%Nx
	    sp(i)=-5.0000+10.0000*swarm%GB(1)%x(i)
	end do
  
  CONTAINS
!==================================================================================================
  SUBROUTINE set_PSO_parameters(swarm)
  
    USE mod_PSO, ONLY: type_PSO_swarm
  
    TYPE(type_PSO_swarm), INTENT(INOUT) :: swarm
    
    ! Control Parameters
    swarm%NeighbourhoodFlag = 'vonNeumannU' ! Type of neighbouthood structure
	swarm%Nparticle         = 100           ! Number of particles
	swarm%Nelite            = 2             ! Number of elitist particles
	swarm%NImax             = 100           ! Maximum number of iterations
	swarm%Nx                = 4             ! Size of decision string *******************need to adjust
	! Standard searching parameters
	swarm%cNB               = 2.0		    ! Weighting coefficient for GB particle 
	swarm%cPB               = 2.0		    ! Weighting coefficient for PB particle
	swarm%cInertiaMax       = 0.9		    ! Maximum inertia coefficient
	swarm%cInertiaMin       = 0.4		    ! Minimum inertia coefficient
	swarm%vMax              = 0.5		    ! Velocity component bound
	! Secondary searching parameters (not needed unless difficult problem, set swarm%perturbNI > swarm%NImax to not use)
	swarm%perturbExp        = 5.0		    ! Perturbation Exponent
	swarm%perturbProb       = 0.20		    ! Perturbation Probability
	swarm%perturbEs         = 0.000005	    ! Expected value for start
	swarm%perturbEe         = 0.0000000005	! Expected value for end
	swarm%perturbNI         = 10001		    ! Start iteration for perturbation
  
  END SUBROUTINE set_PSO_parameters
!==================================================================================================
  SUBROUTINE ComputeObjectiveFunction1(x,y,xr,xc,wp,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::AICk                  !Performance criteria 
    real(8),allocatable::xs(:),ys(:),ye(:)    !Scaled and estimated output
    real(8)::ymin,ymax
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))
    allocate(ye(xr))
    
    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       do c2=1,xc
          ye(c1)=ye(c1)+xs(c1)*wp(c2)
       end do
       ye(c1)=dtanh(ye(c1)+wp(xc+1))
       ye(c1)=(ye(c1)*wp(xc+2)+wp(xc+3))*(ymax-ymin)+ymin
    end do         

  
  AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)
   
    deallocate(xs)
    deallocate(ys)
    deallocate(ye)
   
  END SUBROUTINE 
!==================================================================================================
end subroutine

SUBROUTINE ANN1HN(x,y,xr,xc,wp,ye,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::ye(:),AICk            !Estimated output/Performance criteria 
    real(8),allocatable::xs(:),ys(:)          !Scaled and estimated output
    real(8)::ymin,ymax
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))

    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       do c2=1,xc
          ye(c1)=ye(c1)+xs(c1)*wp(c2)
       end do
       ye(c1)=dtanh(ye(c1)+wp(xc+1))
       ye(c1)=(ye(c1)*wp(xc+2)+wp(xc+3))*(ymax-ymin)+ymin
    end do     
    
     AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)    

    deallocate(xs)
    deallocate(ys)
  
  end subroutine
!***************************END OF 1HN***************

!*****************************PSO MAIN MLP_ANN (2HN)**************************  
Subroutine PSOA2(ix,oy,r,c,sp)  

USE mod_PSO, ONLY: type_PSO_swarm, read_PSO_swarm_from_file, initialise_PSO_swarm,&
re_initialise_PSO_swarm, update_PSO_swarm_bests, update_PSO_swarm_parameters,&
update_PSO_swarm_locations, perturb_PSO_swarm_locations,& 
store_PSO_iteration_data,print_PSO_swarm_iteration_statistics
        
    IMPLICIT NONE
    real(8)::ix(:),oy(:)
    integer(8)::r,c     
    TYPE(type_PSO_swarm), TARGET:: swarm
    REAL(8):: f
    INTEGER(8):: i, j 
    real(8)::sp(:)

    
    CALL set_PSO_parameters(swarm)
    CALL initialise_PSO_swarm(swarm)
! Performing optimisation 
    DO i = 1, swarm%NImax 
      CALL update_PSO_swarm_parameters(swarm,i)
	  DO j = 1, swarm%Nparticle
! Evaluating the particle objective function values
        CALL ComputeObjectiveFunction2(ix,oy,r,c,(-5.0000+10.0000*(swarm%particle(j)%x)),f)  
        swarm%particle(j)%f = f
	  END DO
! Adjusting the PSO parameters
      CALL update_PSO_swarm_bests(swarm)
	  CALL store_PSO_iteration_data(swarm,i)
      CALL update_PSO_swarm_locations(swarm) 
	END DO
	
	!CALL print_PSO_swarm_iteration_statistics(swarm, 10_8)
	
	do i=1,swarm%Nx
	    sp(i)=-5.0000+10.0000*swarm%GB(1)%x(i)
	end do
  
  CONTAINS
!==================================================================================================
  SUBROUTINE set_PSO_parameters(swarm)
  
    USE mod_PSO, ONLY: type_PSO_swarm
  
    TYPE(type_PSO_swarm), INTENT(INOUT) :: swarm
    
    ! Control Parameters
    swarm%NeighbourhoodFlag = 'vonNeumannU' ! Type of neighbouthood structure
	swarm%Nparticle         = 100            ! Number of particles
	swarm%Nelite            = 2             ! Number of elitist particles
	swarm%NImax             = 100           ! Maximum number of iterations
	swarm%Nx                = 7             ! Size of decision string *******************need to adjust
	! Standard searching parameters
	swarm%cNB               = 2.0		    ! Weighting coefficient for GB particle 
	swarm%cPB               = 2.0		    ! Weighting coefficient for PB particle
	swarm%cInertiaMax       = 0.9		    ! Maximum inertia coefficient
	swarm%cInertiaMin       = 0.4		    ! Minimum inertia coefficient
	swarm%vMax              = 0.5		    ! Velocity component bound
	! Secondary searching parameters (not needed unless difficult problem, set swarm%perturbNI > swarm%NImax to not use)
	swarm%perturbExp        = 5.0		    ! Perturbation Exponent
	swarm%perturbProb       = 0.20		    ! Perturbation Probability
	swarm%perturbEs         = 0.000005	    ! Expected value for start
	swarm%perturbEe         = 0.0000000005	! Expected value for end
	swarm%perturbNI         = 10001		    ! Start iteration for perturbation
  
  END SUBROUTINE set_PSO_parameters
!==================================================================================================
  SUBROUTINE ComputeObjectiveFunction2(x,y,xr,xc,wp,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::AICk                  !Performance criteria 
    real(8),allocatable::xs(:),ys(:),ye(:)    !Scaled and estimated output
    real(8)::ymin,ymax,sum1,sum2
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))
    allocate(ye(xr))
    
    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       sum1=0.0
       sum2=0.0
       do c2=1,xc
          sum1=sum1+xs(c1)*wp(c2)
          sum2=sum2+xs(c1)*wp(xc+1+c2)
       end do
       ye(c1)=dtanh(sum1+wp(xc+1))*wp(2*xc+3)+dtanh(sum2+wp(2*xc+2))*wp(2*xc+4)
       ye(c1)=(ye(c1)+wp(2*xc+5))*(ymax-ymin)+ymin
    end do         

  
  AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)
   
    deallocate(xs)
    deallocate(ys)
    deallocate(ye)
   
  END SUBROUTINE 
!==================================================================================================
end subroutine

SUBROUTINE ANN2HN(x,y,xr,xc,wp,ye,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::ye(:),AICk            !Estimated output/Performance criteria 
    real(8),allocatable::xs(:),ys(:)          !Scaled and estimated output
    real(8)::ymin,ymax,sum1,sum2
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))

    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       sum1=0.0
       sum2=0.0
       do c2=1,xc
          sum1=sum1+xs(c1)*wp(c2)
          sum2=sum2+xs(c1)*wp(xc+1+c2)
       end do
       ye(c1)=dtanh(sum1+wp(xc+1))*wp(2*xc+3)+dtanh(sum2+wp(2*xc+2))*wp(2*xc+4)
       ye(c1)=(ye(c1)+wp(2*xc+5))*(ymax-ymin)+ymin
    end do    
    
     AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)    

    deallocate(xs)
    deallocate(ys)
  
  end subroutine
!***************************END OF 2HN***************

!*****************************PSO MAIN MLP_ANN (3HN)**************************  
Subroutine PSOA3(ix,oy,r,c,sp)  

USE mod_PSO, ONLY: type_PSO_swarm, read_PSO_swarm_from_file, initialise_PSO_swarm,&
re_initialise_PSO_swarm, update_PSO_swarm_bests, update_PSO_swarm_parameters,&
update_PSO_swarm_locations, perturb_PSO_swarm_locations,& 
store_PSO_iteration_data,print_PSO_swarm_iteration_statistics
        
    IMPLICIT NONE
    real(8)::ix(:),oy(:)
    integer(8)::r,c     
    TYPE(type_PSO_swarm), TARGET:: swarm
    REAL(8):: f
    INTEGER(8):: i, j 
    real(8)::sp(:)

    
    CALL set_PSO_parameters(swarm)
    CALL initialise_PSO_swarm(swarm)
! Performing optimisation 
    DO i = 1, swarm%NImax 
      CALL update_PSO_swarm_parameters(swarm,i)
	  DO j = 1, swarm%Nparticle
! Evaluating the particle objective function values
        CALL ComputeObjectiveFunction3(ix,oy,r,c,(-5.0000+10.0000*(swarm%particle(j)%x)),f)  
        swarm%particle(j)%f = f
	  END DO
! Adjusting the PSO parameters
      CALL update_PSO_swarm_bests(swarm)
	  CALL store_PSO_iteration_data(swarm,i)
      CALL update_PSO_swarm_locations(swarm) 
	END DO
	
	!CALL print_PSO_swarm_iteration_statistics(swarm, 10_8)
	
	do i=1,swarm%Nx
	    sp(i)=-5.0000+10.0000*swarm%GB(1)%x(i)
	end do
  
  CONTAINS
!==================================================================================================
  SUBROUTINE set_PSO_parameters(swarm)
  
    USE mod_PSO, ONLY: type_PSO_swarm
  
    TYPE(type_PSO_swarm), INTENT(INOUT) :: swarm
    
    ! Control Parameters
    swarm%NeighbourhoodFlag = 'vonNeumannU' ! Type of neighbouthood structure
	swarm%Nparticle         = 100            ! Number of particles
	swarm%Nelite            = 2             ! Number of elitist particles
	swarm%NImax             = 100           ! Maximum number of iterations
	swarm%Nx                = 10            ! Size of decision string *******************need to adjust
	! Standard searching parameters
	swarm%cNB               = 2.0		    ! Weighting coefficient for GB particle 
	swarm%cPB               = 2.0		    ! Weighting coefficient for PB particle
	swarm%cInertiaMax       = 0.9		    ! Maximum inertia coefficient
	swarm%cInertiaMin       = 0.4		    ! Minimum inertia coefficient
	swarm%vMax              = 0.5		    ! Velocity component bound
	! Secondary searching parameters (not needed unless difficult problem, set swarm%perturbNI > swarm%NImax to not use)
	swarm%perturbExp        = 5.0		    ! Perturbation Exponent
	swarm%perturbProb       = 0.20		    ! Perturbation Probability
	swarm%perturbEs         = 0.000005	    ! Expected value for start
	swarm%perturbEe         = 0.0000000005	! Expected value for end
	swarm%perturbNI         = 10001		    ! Start iteration for perturbation
  
  END SUBROUTINE set_PSO_parameters
!==================================================================================================
  SUBROUTINE ComputeObjectiveFunction3(x,y,xr,xc,wp,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::AICk                  !Performance criteria 
    real(8),allocatable::xs(:),ys(:),ye(:)    !Scaled and estimated output
    real(8)::ymin,ymax,sum1,sum2,sum3
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))
    allocate(ye(xr))
    
    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       sum1=0.0
       sum2=0.0
       sum3=0.0
       do c2=1,xc
          sum1=sum1+xs(c1)*wp(c2)
          sum2=sum2+xs(c1)*wp(xc+1+c2)
          sum3=sum3+xs(c1)*wp(2*xc+2+c2)
       end do
       ye(c1)=dtanh(sum1+wp(xc+1))*wp(3*xc+4)+dtanh(sum2+wp(2*xc+2))*wp(3*xc+5)&
       +dtanh(sum3+wp(3*xc+3))*wp(3*xc+6)
       ye(c1)=(ye(c1)+wp(3*xc+7))*(ymax-ymin)+ymin
    end do         

  
  AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)
   
    deallocate(xs)
    deallocate(ys)
    deallocate(ye)
   
  END SUBROUTINE 
!==================================================================================================
end subroutine

SUBROUTINE ANN3HN(x,y,xr,xc,wp,ye,AICk)
  
    IMPLICIT NONE
    REAL(8), INTENT(IN) :: x(:),y(:),wp(:)    !INPUT; OUTPUT; WEIGHT
    INTEGER(8), INTENT(IN) :: xr,xc             !Raw, column
    REAL(8),INTENT(OUT) ::ye(:),AICk            !Estimated output/Performance criteria 
    real(8),allocatable::xs(:),ys(:)          !Scaled and estimated output
    real(8)::ymin,ymax,sum1,sum2,sum3
    integer(8)::c1,c2
    
    allocate(xs(xr))
    allocate(ys(xr))

    do c2=1,xc
       call scaling(x,xr,xs)
    end do
    
    ymin=minval(y)
    ymax=maxval(y)

    do c1=1,xr
       ye(c1)=0.0
       sum1=0.0
       sum2=0.0
       sum3=0.0
       do c2=1,xc
          sum1=sum1+xs(c1)*wp(c2)
          sum2=sum2+xs(c1)*wp(xc+1+c2)
          sum3=sum3+xs(c1)*wp(2*xc+2+c2)
       end do
       ye(c1)=dtanh(sum1+wp(xc+1))*wp(3*xc+4)+dtanh(sum2+wp(2*xc+2))*wp(3*xc+5)&
       +dtanh(sum3+wp(3*xc+3))*wp(3*xc+6)
       ye(c1)=(ye(c1)+wp(3*xc+7))*(ymax-ymin)+ymin
    end do    
    
     AICk=0.0
  do c1=1,xr
     AICk=AICk+(ye(c1)-y(c1))**2.0
  end do
     AICk=xr*dlog(AICk/real(xr))+2.0*(xc+1)    

    deallocate(xs)
    deallocate(ys)
  
  end subroutine
!***************************END OF 3HN***************
!**************************End of PSO MLPANN*********

end Module
